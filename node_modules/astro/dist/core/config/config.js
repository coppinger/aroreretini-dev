import load, { ProloadError, resolve } from "@proload/core";
import loadTypeScript from "@proload/plugin-tsm";
import fs from "fs";
import * as colors from "kleur/colors";
import path from "path";
import { fileURLToPath, pathToFileURL } from "url";
import * as vite from "vite";
import { mergeConfig as mergeViteConfig } from "vite";
import { arraify, isObject, isURL } from "../util.js";
import { createRelativeSchema } from "./schema.js";
load.use([loadTypeScript]);
const LEGACY_ASTRO_CONFIG_KEYS = /* @__PURE__ */ new Set([
  "projectRoot",
  "src",
  "pages",
  "public",
  "dist",
  "styleOptions",
  "markdownOptions",
  "buildOptions",
  "devOptions"
]);
async function validateConfig(userConfig, root, cmd, logging) {
  const fileProtocolRoot = pathToFileURL(root + path.sep);
  if (userConfig.hasOwnProperty("renderers")) {
    console.error('Astro "renderers" are now "integrations"!');
    console.error("Update your configuration and install new dependencies:");
    try {
      const rendererKeywords = userConfig.renderers.map(
        (r) => r.replace("@astrojs/renderer-", "")
      );
      const rendererImports = rendererKeywords.map((r) => `  import ${r} from '@astrojs/${r === "solid" ? "solid-js" : r}';`).join("\n");
      const rendererIntegrations = rendererKeywords.map((r) => `    ${r}(),`).join("\n");
      console.error("");
      console.error(colors.dim("  // astro.config.js"));
      if (rendererImports.length > 0) {
        console.error(colors.green(rendererImports));
      }
      console.error("");
      console.error(colors.dim("  // ..."));
      if (rendererIntegrations.length > 0) {
        console.error(colors.green("  integrations: ["));
        console.error(colors.green(rendererIntegrations));
        console.error(colors.green("  ],"));
      } else {
        console.error(colors.green("  integrations: [],"));
      }
      console.error("");
    } catch (err) {
    }
    process.exit(1);
  }
  let legacyConfigKey;
  for (const key of Object.keys(userConfig)) {
    if (LEGACY_ASTRO_CONFIG_KEYS.has(key)) {
      legacyConfigKey = key;
      break;
    }
  }
  if (legacyConfigKey) {
    throw new Error(
      `Legacy configuration detected: "${legacyConfigKey}".
Please update your configuration to the new format!
See https://astro.build/config for more information.`
    );
  }
  const AstroConfigRelativeSchema = createRelativeSchema(cmd, fileProtocolRoot);
  const result = await AstroConfigRelativeSchema.parseAsync(userConfig);
  return result;
}
function resolveFlags(flags) {
  return {
    root: typeof flags.root === "string" ? flags.root : void 0,
    site: typeof flags.site === "string" ? flags.site : void 0,
    port: typeof flags.port === "number" ? flags.port : void 0,
    config: typeof flags.config === "string" ? flags.config : void 0,
    host: typeof flags.host === "string" || typeof flags.host === "boolean" ? flags.host : void 0,
    drafts: typeof flags.drafts === "boolean" ? flags.drafts : void 0
  };
}
function resolveRoot(cwd) {
  return cwd ? path.resolve(cwd) : process.cwd();
}
function mergeCLIFlags(astroConfig, flags, cmd) {
  astroConfig.server = astroConfig.server || {};
  astroConfig.markdown = astroConfig.markdown || {};
  if (typeof flags.site === "string")
    astroConfig.site = flags.site;
  if (typeof flags.drafts === "boolean")
    astroConfig.markdown.drafts = flags.drafts;
  if (typeof flags.port === "number") {
    astroConfig.server.port = flags.port;
  }
  if (typeof flags.host === "string" || typeof flags.host === "boolean") {
    astroConfig.server.host = flags.host;
  }
  return astroConfig;
}
async function resolveConfigPath(configOptions) {
  const root = resolveRoot(configOptions.cwd);
  const flags = resolveFlags(configOptions.flags || {});
  let userConfigPath;
  if (flags == null ? void 0 : flags.config) {
    userConfigPath = /^\.*\//.test(flags.config) ? flags.config : `./${flags.config}`;
    userConfigPath = fileURLToPath(new URL(userConfigPath, `file://${root}/`));
  }
  try {
    const configPath = await resolve("astro", {
      mustExist: !!userConfigPath,
      cwd: root,
      filePath: userConfigPath
    });
    return configPath;
  } catch (e) {
    if (e instanceof ProloadError && flags.config) {
      throw new Error(`Unable to resolve --config "${flags.config}"! Does the file exist?`);
    }
    throw e;
  }
}
async function openConfig(configOptions) {
  const root = resolveRoot(configOptions.cwd);
  const flags = resolveFlags(configOptions.flags || {});
  let userConfig = {};
  const config = await tryLoadConfig(configOptions, flags, root);
  if (config) {
    userConfig = config.value;
  }
  const astroConfig = await resolveConfig(
    userConfig,
    root,
    flags,
    configOptions.cmd,
    configOptions.logging
  );
  return {
    astroConfig,
    userConfig,
    flags,
    root
  };
}
async function tryLoadConfig(configOptions, flags, root) {
  let finallyCleanup = async () => {
  };
  try {
    let configPath = await resolveConfigPath({
      cwd: configOptions.cwd,
      flags: configOptions.flags
    });
    if (!configPath)
      return void 0;
    if (configOptions.isRestart) {
      const tempConfigPath = path.join(
        root,
        `.temp.${Date.now()}.config${path.extname(configPath)}`
      );
      await fs.promises.writeFile(tempConfigPath, await fs.promises.readFile(configPath));
      finallyCleanup = async () => {
        try {
          await fs.promises.unlink(tempConfigPath);
        } catch {
        }
      };
      configPath = tempConfigPath;
    }
    const config = await load("astro", {
      mustExist: !!configPath,
      cwd: root,
      filePath: configPath
    });
    return config;
  } catch (e) {
    if (e instanceof ProloadError && flags.config) {
      throw new Error(`Unable to resolve --config "${flags.config}"! Does the file exist?`);
    }
    const configPath = await resolveConfigPath(configOptions);
    if (!configPath) {
      throw e;
    }
    const viteServer = await vite.createServer({
      server: { middlewareMode: true, hmr: false },
      optimizeDeps: { entries: [] },
      clearScreen: false,
      appType: "custom",
      ssr: {
        external: ["@astrojs/mdx", "@astrojs/react"]
      }
    });
    try {
      const mod = await viteServer.ssrLoadModule(configPath);
      if (mod == null ? void 0 : mod.default) {
        return {
          value: mod.default,
          filePath: configPath
        };
      }
    } finally {
      await viteServer.close();
    }
  } finally {
    await finallyCleanup();
  }
}
async function loadConfig(configOptions) {
  const root = resolveRoot(configOptions.cwd);
  const flags = resolveFlags(configOptions.flags || {});
  let userConfig = {};
  const config = await tryLoadConfig(configOptions, flags, root);
  if (config) {
    userConfig = config.value;
  }
  return resolveConfig(userConfig, root, flags, configOptions.cmd, configOptions.logging);
}
async function resolveConfig(userConfig, root, flags = {}, cmd, logging) {
  const mergedConfig = mergeCLIFlags(userConfig, flags, cmd);
  const validatedConfig = await validateConfig(mergedConfig, root, cmd, logging);
  return validatedConfig;
}
function mergeConfigRecursively(defaults, overrides, rootPath) {
  const merged = { ...defaults };
  for (const key in overrides) {
    const value = overrides[key];
    if (value == null) {
      continue;
    }
    const existing = merged[key];
    if (existing == null) {
      merged[key] = value;
      continue;
    }
    if (key === "vite" && rootPath === "") {
      merged[key] = mergeViteConfig(existing, value);
      continue;
    }
    if (Array.isArray(existing) || Array.isArray(value)) {
      merged[key] = [...arraify(existing ?? []), ...arraify(value ?? [])];
      continue;
    }
    if (isURL(existing) && isURL(value)) {
      merged[key] = value;
      continue;
    }
    if (isObject(existing) && isObject(value)) {
      merged[key] = mergeConfigRecursively(existing, value, rootPath ? `${rootPath}.${key}` : key);
      continue;
    }
    merged[key] = value;
  }
  return merged;
}
function mergeConfig(defaults, overrides, isRoot = true) {
  return mergeConfigRecursively(defaults, overrides, isRoot ? "" : ".");
}
export {
  LEGACY_ASTRO_CONFIG_KEYS,
  loadConfig,
  mergeConfig,
  openConfig,
  resolveConfig,
  resolveConfigPath,
  resolveFlags,
  resolveRoot,
  validateConfig
};
