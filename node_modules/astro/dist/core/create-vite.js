import fs from "fs";
import { createRequire } from "module";
import path from "path";
import { fileURLToPath } from "url";
import * as vite from "vite";
import astroPostprocessVitePlugin from "../vite-plugin-astro-postprocess/index.js";
import astroViteServerPlugin from "../vite-plugin-astro-server/index.js";
import astroVitePlugin from "../vite-plugin-astro/index.js";
import configAliasVitePlugin from "../vite-plugin-config-alias/index.js";
import envVitePlugin from "../vite-plugin-env/index.js";
import htmlVitePlugin from "../vite-plugin-html/index.js";
import astroIntegrationsContainerPlugin from "../vite-plugin-integrations-container/index.js";
import jsxVitePlugin from "../vite-plugin-jsx/index.js";
import legacyMarkdownVitePlugin from "../vite-plugin-markdown-legacy/index.js";
import markdownVitePlugin from "../vite-plugin-markdown/index.js";
import astroScriptsPlugin from "../vite-plugin-scripts/index.js";
import astroScriptsPageSSRPlugin from "../vite-plugin-scripts/page-ssr.js";
import { createCustomViteLogger } from "./errors.js";
import { resolveDependency } from "./util.js";
const ALWAYS_NOEXTERNAL = /* @__PURE__ */ new Set([
  "astro",
  "astro/components",
  "@nanostores/preact",
  "@fontsource/*"
]);
function getSsrNoExternalDeps(projectRoot) {
  let noExternalDeps = [];
  for (const dep of ALWAYS_NOEXTERNAL) {
    try {
      resolveDependency(dep, projectRoot);
      noExternalDeps.push(dep);
    } catch {
    }
  }
  return noExternalDeps;
}
async function createVite(commandConfig, { settings, logging, mode }) {
  const thirdPartyAstroPackages = await getAstroPackages(settings);
  const commonConfig = {
    cacheDir: fileURLToPath(new URL("./node_modules/.vite/", settings.config.root)),
    clearScreen: false,
    logLevel: "warn",
    appType: "custom",
    optimizeDeps: {
      entries: ["src/**/*"],
      exclude: ["node-fetch"]
    },
    plugins: [
      configAliasVitePlugin({ settings }),
      astroVitePlugin({ settings, logging }),
      astroScriptsPlugin({ settings }),
      mode !== "build" && astroViteServerPlugin({ settings, logging }),
      envVitePlugin({ settings }),
      settings.config.legacy.astroFlavoredMarkdown ? legacyMarkdownVitePlugin({ settings, logging }) : markdownVitePlugin({ settings, logging }),
      htmlVitePlugin(),
      jsxVitePlugin({ settings, logging }),
      astroPostprocessVitePlugin({ settings }),
      astroIntegrationsContainerPlugin({ settings, logging }),
      astroScriptsPageSSRPlugin({ settings })
    ],
    publicDir: fileURLToPath(settings.config.publicDir),
    root: fileURLToPath(settings.config.root),
    envPrefix: "PUBLIC_",
    define: {
      "import.meta.env.SITE": settings.config.site ? `'${settings.config.site}'` : "undefined"
    },
    server: {
      hmr: process.env.NODE_ENV === "test" || process.env.NODE_ENV === "production" ? false : void 0,
      proxy: {},
      watch: {
        ignored: mode === "build" ? ["**"] : void 0
      }
    },
    css: {
      postcss: settings.config.style.postcss || {}
    },
    resolve: {
      alias: [
        {
          find: "randombytes",
          replacement: "randombytes/browser"
        },
        {
          find: /^astro$/,
          replacement: fileURLToPath(new URL("../@types/astro", import.meta.url))
        }
      ],
      conditions: ["astro"]
    },
    ssr: {
      noExternal: [...getSsrNoExternalDeps(settings.config.root), ...thirdPartyAstroPackages],
      external: mode === "dev" ? ["shiki"] : []
    }
  };
  let result = commonConfig;
  result = vite.mergeConfig(result, settings.config.vite || {});
  result = vite.mergeConfig(result, commandConfig);
  if (result.plugins) {
    sortPlugins(result.plugins);
  }
  result.customLogger = createCustomViteLogger(result.logLevel ?? "warn");
  return result;
}
function isVitePlugin(plugin) {
  return Boolean(plugin == null ? void 0 : plugin.hasOwnProperty("name"));
}
function findPluginIndexByName(pluginOptions, name) {
  return pluginOptions.findIndex(function(pluginOption) {
    return isVitePlugin(pluginOption) && pluginOption.name === name;
  });
}
function sortPlugins(pluginOptions) {
  const mdxPluginIndex = findPluginIndexByName(pluginOptions, "@mdx-js/rollup");
  if (mdxPluginIndex === -1)
    return;
  const jsxPluginIndex = findPluginIndexByName(pluginOptions, "astro:jsx");
  const mdxPlugin = pluginOptions[mdxPluginIndex];
  pluginOptions.splice(mdxPluginIndex, 1);
  pluginOptions.splice(jsxPluginIndex, 0, mdxPlugin);
}
async function getAstroPackages(settings) {
  const { astroPackages } = new DependencyWalker(settings.config.root);
  return astroPackages;
}
class DependencyWalker {
  constructor(root) {
    this.astroDeps = /* @__PURE__ */ new Set();
    this.nonAstroDeps = /* @__PURE__ */ new Set();
    const pkgUrl = new URL("./package.json", root);
    this.require = createRequire(pkgUrl);
    const pkgPath = fileURLToPath(pkgUrl);
    if (!fs.existsSync(pkgPath))
      return;
    const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf8"));
    const deps = [
      ...Object.keys(pkg.dependencies || {}),
      ...Object.keys(pkg.devDependencies || {})
    ];
    this.scanDependencies(deps);
  }
  get astroPackages() {
    return Array.from(this.astroDeps);
  }
  seen(dep) {
    return this.astroDeps.has(dep) || this.nonAstroDeps.has(dep);
  }
  readPkgJSON(dir) {
    try {
      const filePath = path.join(dir, "package.json");
      return JSON.parse(fs.readFileSync(filePath, "utf-8"));
    } catch (e) {
    }
  }
  resolvePkgJSON(dep) {
    try {
      const pkgJson = this.require(dep + "/package.json");
      return pkgJson;
    } catch (e) {
      try {
        let dir = path.dirname(this.require.resolve(dep));
        while (dir) {
          const pkgJSON = this.readPkgJSON(dir);
          if (pkgJSON && pkgJSON.name === dep)
            return pkgJSON;
          const parentDir = path.dirname(dir);
          if (parentDir === dir)
            break;
          dir = parentDir;
        }
      } catch {
      }
    }
  }
  scanDependencies(deps) {
    const newDeps = [];
    for (const dep of deps) {
      if (isCommonNotAstro(dep)) {
        this.nonAstroDeps.add(dep);
        continue;
      }
      const pkgJson = this.resolvePkgJSON(dep);
      if (!pkgJson) {
        this.nonAstroDeps.add(dep);
        continue;
      }
      const { dependencies = {}, peerDependencies = {}, keywords = [] } = pkgJson;
      if (peerDependencies.astro || dependencies.astro || keywords.includes("astro") || keywords.includes("astro-component") || /^(@[^\/]+\/)?astro\-/.test(dep)) {
        this.astroDeps.add(dep);
        const unknownDependencies = Object.keys(dependencies).filter((d) => !this.seen(d));
        newDeps.push(...unknownDependencies);
      } else {
        this.nonAstroDeps.add(dep);
      }
    }
    if (newDeps.length)
      this.scanDependencies(newDeps);
  }
}
const COMMON_DEPENDENCIES_NOT_ASTRO = [
  "autoprefixer",
  "react",
  "react-dom",
  "preact",
  "preact-render-to-string",
  "vue",
  "svelte",
  "solid-js",
  "lit",
  "cookie",
  "dotenv",
  "esbuild",
  "eslint",
  "jest",
  "postcss",
  "prettier",
  "astro",
  "tslib",
  "typescript",
  "vite"
];
const COMMON_PREFIXES_NOT_ASTRO = [
  "@webcomponents/",
  "@fontsource/",
  "@postcss-plugins/",
  "@rollup/",
  "@astrojs/renderer-",
  "@types/",
  "@typescript-eslint/",
  "eslint-",
  "jest-",
  "postcss-plugin-",
  "prettier-plugin-",
  "remark-",
  "rehype-",
  "rollup-plugin-",
  "vite-plugin-"
];
function isCommonNotAstro(dep) {
  return COMMON_DEPENDENCIES_NOT_ASTRO.includes(dep) || COMMON_PREFIXES_NOT_ASTRO.some(
    (prefix) => prefix.startsWith("@") ? dep.startsWith(prefix) : dep.substring(dep.lastIndexOf("/") + 1).startsWith(prefix)
  );
}
export {
  createVite
};
